/* Copyright (c) 2016 Cameron Harper
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * 
 * */

/* includes ***********************************************************/

#include "groups.h"
#include "blink_compact.h"
#include "blink_stream.h"

#include <string.h>

/* types **************************************************************/

struct blink_enum {
    int32_t value;
    const char *name;
    size_t nameLen;
};

struct group_base {
    enum group_type type;
    struct blink_allocator a;
};

<%@schema.groups.each do |g| -%>
struct <%= cname(g.name) %> {

    struct group_base super;
    
<%  g.fields.each do |f| -%>
    struct {

        bool initialised;
<%    case f.type.class
      when STRING, BINARY, FIXED -%>
<%      if f.type.is_a? FIXED or f.type.size -%>
        struct {
            uint8_t data[<%= f.type.size %>U];
            uint32_t size;
        } value;
<%      else -%>
        struct {
            uint8_t *data;
            uint32_t size;
        } value;        
<%      end -%>
<%    when ENUM -%>
        int32_t value;
<%    else -%>
        <%= value_type(f.type) -%> value;
<%    end -%>        
    } <%= f.name %>;

<%  end -%>
};

<%end -%>

/* variables **********************************************************/

<%@schema.definitions.select{|d|d.is_a? Definition and d.type.is_a? ENUM}.each do |e| -%>
static const struct blink_enum <%= cname(e.name) %>[] = {
<%  e.type.symbols.each do |s| -%>
    {<%= s.value %>, "<%= s.name%>", sizeof("<%= s.name%>")-1U},
<%  end-%>
};
<%end-%>

struct group_table {
    enum blink_type type;
    uint64_t id;
};

static const struct group_table groups[] = {
<%@schema.groups.each.select{|g|g.id}.each do |g| %>
    {TYPE_<%= cname(g.name) %>, <%= g.id %>U},
<%end%>
};

/* static function prototypes *****************************************/

<%@schema.groups.each do |g| -%>
<%  if g.id -%>
static bool <%= cname(g.name) %>_encodeCompactGroup(struct <%= cname(g.name) %> *self, blink_stream_t out);
<%  end -%>
static bool <%= cname(g.name) %>_encodeCompactBody(struct <%= cname(g.name) %> *self, blink_stream_t out);
static bool <%= cname(g.name) %>_sizeof(struct <%= cname(g.name) %> *self, uint32_t *size);
<%end -%>


/* functions **********************************************************/

group_t decodeCompact(blink_stream_t in, struct blink_allocator alloc)
{
    group_t retval = NULL;
    uint32_t size;
    bool isNull;

    if(BLINK_Compact_getU32(in, &isNull, &size)){

        if(!isNull{

            if(size == 0U){

                BLINK_ERROR("group size cannot be zero")
            }
            else{

                if(BLINK_Compact_getU64(in, &isNull, &id){

                    if(isNull){

                        BLINK_ERROR("group ID cannot be NULL")
                    }
                    else{

                        switch(id){
<%@schema.groups.select{|g|g.id}.each do |g|-%>
                        case <%= g.id %>U:

                            retval = <%= cname(g.name) %>_new(alloc);
                            if(retval != NULL){
                        
                                if(!<%= cname(g.name) %>_decodeCompactBody(in, (struct <%= cname(g.name) %> *)group)){
        
                                    <%= cname(g.name) %>_destroy(group);
                                    retval = NULL;
                                }
                            }

                            break;
<%end -%>
                        default:
                        
                            BLINK_ERROR("group id is unknown")

                            //vend unknown groups here??
                            
                            /* read past the unknown group */
                            while(size > 0){
                                uint8_t buf;
                                if(!BLINK_Stream_read(in, &buf, sizeof(buf))){
                                    break;
                                }
                                size--;
                            }            
                            break;                            
                        }
                    }
                }
            }
        }
    }

    return retval;
}

bool encodeCompact(object_t group, blink_stream_t out)
{
    bool retval = false;

    switch(group->type){
<%@schema.groups.select{|g|g.id}.each do |g| -%>
    case TYPE_<%= cname(g.name) %>:
        retval = <%= cname(g.name) %>_encodeCompactGroup((struct <%= cname(g.name) %> *)group, blink_stream_t out);
        break;
<%end -%>
<%@schema.groups.select{|g|g.id.nil?}.each do |g| -%>
    case <%= cname(g.name) %>:
<%end -%>
    default:
        /* cannot encode */
        break;
    }

    return retval;
}

<%@schema.groups.each do |g| -%>

object_t <%= cname(g.name) %>_new(struct blink_allocator alloc)
{
    struct <%= cname(g.name) %> *retval = NULL;

    if(alloc.calloc != NULL){
    
        retval = alloc.calloc(sizeof(struct <%= cname(g.name) %>), 1U);
        
        if(retval != NULL){
        
            retval->super.type = TYPE_<%= cname(g.name) %>;
            retval->super.a = alloc;
        }
        else{
        
            BLINK_ERROR("calloc()")
        }
    }
    else{
    
        BLINK_ERROR("cannot create a new group without an allocator")
    }
    
    return (object_t)retval;
}
<%end -%>

<%@schema.groups.each do |g| -%>
<%  g.fields.each do |f| -%>

<%= value_type(f.type) %> <%= cname(g.name) %>_get_<%= f.name %>(object_t group)
{
<%    if @options[:typeAssert] -%>
    BLINK_ASSERT(group->type == TYPE_<%= cname(g.name) %>)
    
<%    end -%>
    if(group->type == TYPE_<%= cname(g.name) %>){

        struct <%= cname(g.name) %> *self = (struct <%= cname(g.name) %> *)group;
<%    case f.type.class
      when STRING, BINARY, FIXED -%>
        struct blink_string retval = {.data = self-><%= f.name %>.value.data, .size = self-><%= f.name %>.value.size};
        return retval;  
<%    when DECIMAL -%>
        struct blink_decimal retval = {.exponent = self-><%= f.name %>.value.exponent, .mantissa = self-><%= f.name %>.value.mantissa});
        return retval;
<%    when ENUM %>
        const char *retval = NULL;
        uint32_t i;
        for(i=0U; i < sizeof(<%= cname(f.type.name) %>)/sizeof(*<%= cname(f.type.name) %>); i++){
            if(<%= cname(f.type.name) %>[i].value == self-><%= f.name %>.value){

                retval = <%= cname(f.type.name) %>[i].name;
                break;
            }           
        }
        return retval;    
<%    else -%>
        return self-><%= f.name %>.value;
<%    end -%>
    }
    else{

<%    case f.type.class
      when STRING, BINARY, FIXED -%>
        struct blink_string retval = {.data = NULL, .size = 0U};
        return retval;  
<%    when DECIMAL -%>
        struct blink_decimal retval = {.exponent = 0, .mantissa = 0});
        return retval;
<%    when ENUM %>
        return NULL;
<%    else -%>
        return 0;
<%    end -%>
    }
}

bool <%= cname(g.name) %>_set_<%= f.name %>(object_t group, <%= value_type(f.type) %> value)
{
    bool retval = false;

<% if @options[:typeAssert] -%>
    BLINK_ASSERT(group->type == TYPE_<%= cname(g.name) %>)
    
<% end -%>
    if(group->type == TYPE_<%= cname(g.name) %>){

        struct <%= cname(g.name) %> *self = (struct <%= cname(g.name) %> *)group;
    
<%    case f.type.class
      when STRING, BINARY, FIXED -%>
<%      if f.type.is_a? FIXED or f.type.size -%>
        if(sizeof(self-><%= f.name %>.value.data) >= value.size){

            (void)memcpy(self-><%= f.name %>.value.data, value.data, value.size);
            retval = true;
        }
        else{
        
            BLINK_ERROR("value is larger than field capacity")
        }
<%      else -%>
        if((self-><%= f.name %>.value.data != NULL) && (self->super.a.free != NULL)){

            self->super.a.free(self-><%= f.name %>.value.data);
            self-><%= f.name %>.value.data = NULL;
            self-><%= f.name %>.value.size = 0U;                        
        }
        
        self-><%= f.name %>.value.data = self->super.a.calloc(value.size, 1U);

        if(self-><%= f.name %>.value.data != NULL){
        
            self-><%= f.name %>.value.size = value.size;
            (void)memcpy(self-><%= f.name %>.value.data, value.data, value.size);
            retval = true;
        }
        else{

            BLINK_ERROR("calloc()")
        }      
<%      end -%>
<%    when DECIMAL -%>

        self-><%= f.name %>.value.mantissa = value.mantissa;
        self-><%= f.name %>.value.exponent = value.exponent;
        retval = true;
    
<%    when ENUM -%>
        uint32_t i;
        for(i=0U; i < sizeof(<%= cname(f.type.name) %>)/sizeof(*<%= cname(f.type.name) %>); i++){
            if(strncmp(<%= cname(f.type.name) %>[i].nameLen, <%= cname(f.type.name) %>[i].name, value) == 0){
                
                self-><%= f.name %>.value = <%= cname(f.type.name) %>[i].value;
                retval = true;
                break;
            }           
        }
<%    when DynamicGroup -%>
        switch(value->type){
<%      f.type.groups.each do |permitted| %>
    case TYPE_<%= cname(permitted.name) %>:
<%      end %>
            self-><%= f.name %>.value = value;
            retval = true;
        default:
            BLINK_ERROR("group is incompatible with field")
            break;
        }
<%    when DynamicGroup -%>
        retval = true;
<%    else -%>
        self-><%= f.name %>.value = value;
        retval = true;
<%    end -%>
    }

    self-><%=f.name %>.initialised = retval;
    
    return retval;
}

bool <%= cname(g.name) %>_test_<%= f.name %>(object_t group)
{
    bool retval = false;

<% if @options[:typeAssert] -%>
    BLINK_ASSERT(group->type == TYPE_<%= cname(g.name) %>)
    
<% end -%>
    if(group->type == TYPE_<%= cname(g.name) %>){

        struct <%= cname(g.name) %> *self = (struct <%= cname(g.name) %> *)group;

        retval = self-><%= f.name %>.initialised;
    }
    
    return retval;
}
<%  end -%>
<%end -%>

/* static functions ***************************************************/

<%@schema.groups.select{|g|g.id}.each do |g| -%>

static bool <%= cname(g.name) %>_encodeCompactGroup(struct <%= cname(g.name) %> *self, blink_stream_t out)
{
    bool retval = false;
    uint32_t size;
    
    if(<%= cname(g.name) %>_sizeof(self, &size)){

        do{

            size += BLINK_Compact_sizeofUnsigned(<%= g.id %>U);

            /* todo: calculate size of extensions here */
        
            if(!BLINK_Compact_encodeU32(size, out)){
                break;
            }
            if(!BLINK_Compact_encodeU64(<%= g.id %>U, out)){
                break;
            }
            if(!<%= cname(g.name) %>_encodeCompactBody(self, out)){
                break;
            }

            retval = true;            
        }
        while(false);        
    }
    

    return retval;
}
<% end -%>

<%@schema.groups.each do |g| -%>

static bool <%= cname(g.name) %>_encodeCompactBody(struct <%= cname(g.name) %> *self, blink_stream_t out)
{
    bool retval = false;

    do{
            
<%  g.fields.each do |f| -%>

        if(self-><%= f.name %>.initialised){

<%    case f.type.class
  when STRING, BINARY -%>
            if(!BLINK_Compact_encodeU32(self-><%= f.name %>.value.size, out)){
                break;
            }
            if(!BLINK_Stream_write(out, self-><%= f.name %>.value.data, self-><%= f.name %>.value.size)){
                break;
            }
<%    when FIXED -%>
<%      if f.optional? -%>
            if(!BLINK_Compact_encodePresent(out)){
                break;
            }
<%      end %>
            if(!BLINK_Stream_write(out, self-><%= f.name %>.value.data, self-><%= f.name %>.value.size)){
                break;
            }
<%    when DECIMAL -%>
            if(!BLINK_Compact_encodeI8(self-><%= f.name %>.value.exponent, out)){
                break;
            }
            if(!BLINK_Compact_encodeI64(self-><%= f.name %>.value.mantissa, out)){
                break;
            }
<%    when BOOLEAN -%>
            if(!BLINK_Compact_encodeBool(self-><%= f.name %>.value, out)){
                break;
            }                
<%    when I8 -%>
            if(!BLINK_Compact_encodeI8(self-><%= f.name %>.value, out)){
                break;
            }
<%    when I16 -%>
            if(!BLINK_Compact_encodeI16(self-><%= f.name %>.value, out)){
                break;
            }                        
<%    when I32, DATE, ENUM -%>
            if(!BLINK_Compact_encodeI32(self-><%= f.name %>.value, out)){
                break;
            }
<%    when I64, NANO_TIME, MILLI_TIME -%>
            if(!BLINK_Compact_encodeI64(self-><%= f.name %>.value, out)){
                break;
            }
<%    when U8 -%>
            if(!BLINK_Compact_encodeU8(self-><%= f.name %>.value, out)){
                break;
            }
<%    when U16 -%>
            if(!BLINK_Compact_encodeU16(self-><%= f.name %>.value, out)){
                break;
            }
<%    when U32, TIME_OF_DAY_MILLI -%>
            if(!BLINK_Compact_encodeU32(self-><%= f.name %>.value, out)){
                break;
            }
<%    when U64, TIME_OF_DAY_NANO -%>                
            if(!BLINK_Compact_encodeU64(self-><%= f.name %>.value, out)){
                break;
            }
<%    when FLOATING_POINT -%>
            if(!BLINK_Compact_encodeF64(self-><%= f.name %>.value, out)){
                break;
            }                
<%    when StaticGroup -%>
            BLINK_ASSERT(self-><%= f.name %>.value != NULL)
            if(!<%= cname(f.type.name) %>_encodeCompactBody(self-><%= f.name %>.value, out)){
                break;
            }
<%    when DynamicGroup -%>
            BLINK_ASSERT(self-><%= f.name %>.value != NULL)
            if(!<%= cname(f.type.name) %>_encodeCompact(self-><%= f.name %>.value, out)){
                break;
            }        
<%    else -%>
<%      raise -%>
<%    end -%>
        }
        else{

            if(!BLINK_Compact_encodeNull(out)){
                break;                    
            }            
        }                 
<%  end -%>

        retval = true;
        
    }
    while(false);
        
    return retval;
}

/* calculate size of fields in the group and check that all mandatory fields
 * are initialised */
static bool <%= cname(g.name) %>_sizeof(struct <%= cname(g.name) %> *self, uint32_t *size)
{
    bool retval = true;

    *size = 0U;

<%  g.fields.each do |f| %>

    if(self-><%= f.name %>.initialised){

<%    case f.type.class
      when STRING, BINARY -%>

        *size += BLINK_Compact_sizeofUnsigned(self-><%= f.name %>.value.size);
        *size += self-><%= f.name %>.value.size;

<%    when FIXED -%>

<%      if f.optional? -%>
        *size += 1U;
<%      end -%>

        *size += self-><%= f.name %>.value.size;

<%    when I8, I16, I32, I64, TIME_OF_DAY_MILLI, TIME_OF_DAY_NANO -%>
    
        *size += BLINK_Compact_sizeofSigned((int64_t)self-><%= f.name %>.value);
        
<%    when U8, U16, U32, U64, MILLI_TIME, NANO_TIME -%>
    
        *size += BLINK_Compact_sizeofUnsigned((uint64_t)self-><%= f.name %>.value);
        
<%    when StaticGroup -%>

        BLINK_ASSERT(self-><%= f.name %>.value != NULL)

        uint32_t groupSize;

        if(!<%= cname(f.type.name) %>_sizeof(self-><%= f.name %>.value, &groupSize)){

            retval = false;
        }
        else{

            *size += groupSize;
<%      if f.optional? -%>
            *size += 1U;
<%      end -%>
        }


<%    when DynamicGroup -%>

        BLINK_ASSERT(self-><%= f.name %>.value != NULL)

        uint32_t groupSize;

        switch(self-><%= f.name %>.value->type){
        default:
<%      f.type.groups.each do |permitted| -%>
        case TYPE_<%= permitted.name %>:
        
            if(!<%= cname(f.type.name) %>_sizeof((struct <%= cname(f.type.name) %> *)self-><%= f.name %>.value, &groupSize)){

                retval = false;
            }
            else{

                *size += BLINK_Compact_sizeofUnsigned(*size);
                *size += BLINK_Compact_sizeofUnsigned(<%= f.type.id %>);
                *size += groupSize;
            }
            break;
<%      end -%>            
        }
<%      %>


        if(!<%= cname(f.type.name) %>_sizeof(self-><%= f.name %>.value, size)){

            retval = false;
        }
        else{


            
        }

<%    end -%>
    }
    else{
<%    if f.optional? -%>

        *size += 1U;
<%    else -%>

        BLINK_ERROR("<%= f.name %> must be initialised")
        return false;            
<%    end -%>    
    }        
<%  end -%>

    return retval;
}

static bool <%= cname(g.name) %>_decodeCompactGroup(blink_stream_t in, struct <%= cname(g.name) %> *self, uint32_t groupSize)
{
    bool retval = false;
    size_t size;
    bool isNull;

    do {
    
<%  g.fields.each do |f| %>
<%    case f.type.class
      when STRING, BINARY -%>
        if(!BLINK_Compact_decodeU32(in, &size, &isNull)){
            break;
        }
        if(!isNull){

<%      if f.type.size %>
            if(size <= <%= g.type.size %>U){

                if(!BLINK_Stream_read(in, self-><%= f.name %>.value.data, size)){
                    break;
                }
            }
<%      else %>
            self-><%= f.name %>.value.data = self.a.calloc(size, 1U);
            if(self-><%= f.name %>.value.data != NULL){

                if(!BLINK_Stream_read(in, self-><%= f.name %>.value.data, size)){
                    break;
                }
            }
            else{

                BLINK_ERROR("calloc()")
            }
<%      end %>
        }
<%    when FIXED -%>
<%      if f.optional? -%>
        if(!BLINK_Compact_decodePresent(in, &present)){
            break;
        }
<%      else %>
        present = true;
<%      end %>
        if(present){
        
            if(!BLINK_Stream_read(in, self-><%= f.name %>.value.data, self-><%= f.name %>.value.size)){
                break;
            }
        }
<%    when DECIMAL -%>
        if(!BLINK_compact_decodeDecimal(in, &self-><%= f.name %>.value.mantissa, &self-><%= f.name %>.value.exponent, &isNull)){
            break;
        }
<%    when BOOLEAN -%>
        if(!BLINK_Compact_decodeBool(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }                
<%    when I8 -%>
        if(!BLINK_Compact_decodeI8(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }            
<%    when I16 -%>
        if(!BLINK_Compact_decodeI16(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }                        
<%    when I32, DATE, ENUM -%>
        if(!BLINK_Compact_decodeI32(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }
<%    when I64, NANO_TIME, MILLI_TIME -%>
        if(!BLINK_Compact_decodeI64(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }
<%    when U8 -%>
        if(!BLINK_Compact_decodeU8(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }
<%    when U16 -%>
        if(!BLINK_Compact_decodeU16(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }
<%    when U32, TIME_OF_DAY_MILLI -%>
        if(!BLINK_Compact_decodeU32(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }
<%    when U64, TIME_OF_DAY_NANO -%>                
        if(!BLINK_Compact_decodeU64(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }
<%    when FLOATING_POINT -%>
        if(!BLINK_Compact_decodeF64(in, &self-><%= f.name %>.value, &isNull)){
            break;
        }                
<%    when StaticGroup -%>
        BLINK_ASSERT(self-><%= f.name %>.value != NULL)
        if(!<%= cname(f.type.name) %>_decodeCompactBody(self-><%= f.name %>.value, out)){
            break;
        }
<%    when DynamicGroup -%>
        BLINK_ASSERT(self-><%= f.name %>.value != NULL)
        if(!<%= cname(f.type.name) %>_decodeCompact(self-><%= f.name %>.value, out)){
            break;
        }        
<%    else -%>
<%      raise -%>
<%    end -%>

        if(isNull){

            if(self-><%= f.name %>.
            if(<%= f.optional? %>)
            
            self-><%= f.name %>.value.initialised = false;
        }
<%  end -%>

        retval = true;
    }
    while(false);

    return retval;    
}
<%end -%>


