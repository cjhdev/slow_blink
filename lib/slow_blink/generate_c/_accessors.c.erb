<%@schema.groups.each do |g| -%>
<%  g.fields.each do |f| -%>

<%    if f.type.sequence? -%>

bool <%= gname(g) %>_append_<%= f.name %>(object_t group, <%= value_type(f.type) %> value)
{
    bool retval = false;




    return false;   //todo
}

void <%= gname(g) %>_iterate_<%= f.name %>(object_t group, bool (*each)(void *user, <%= value_type(f.type) %> value))
{
    struct <%= f.name %> *ptr = self-><%= fname(f) %>.head;

    while(ptr != NULL){

        if(!each(user, ptr->value)){

            break;
        }

        ptr = ptr->next;
    }
}

<%    else -%>

<%= value_type(f.type) %> <%= gname(g) %>_get_<%= f.name %>(object_t group)
{
<%      if @options[:typeAssert] -%>
    BLINK_ASSERT(group->type == TYPE_<%= gname(g) %>)
    
<%      end -%>
    if(group->type == TYPE_<%= gname(g) %>){

        struct <%= gname(g) %> *self = (struct <%= gname(g) %> *)group;
<%      case f.type.class
        when STRING, BINARY, FIXED -%>
        struct blink_string retval = {.data = self-><%= fname(f) %>.value.data, .size = self-><%= fname(f) %>.value.size};
        return retval;  
<%      when DECIMAL -%>
        struct blink_decimal retval = {.exponent = self-><%= fname(f) %>.value.exponent, .mantissa = self-><%= fname(f) %>.value.mantissa});
        return retval;
<%      when ENUM %>
        const char *retval = NULL;
        uint32_t i;
        for(i=0U; i < sizeof(<%= gname(f.type) %>)/sizeof(*<%= gname(f.type) %>); i++){
            if(<%= gname(f.type) %>[i].value == self-><%= fname(f) %>.value){

                retval = <%= gname(f.type) %>[i].name;
                break;
            }           
        }
        return retval;    
<%      else -%>
        return self-><%= fname(f) %>.value;
<%      end -%>
    }
    else{

<%      case f.type.class
        when STRING, BINARY, FIXED -%>
        struct blink_string retval = {.data = NULL, .size = 0U};
        return retval;  
<%      when DECIMAL -%>
        struct blink_decimal retval = {.exponent = 0, .mantissa = 0});
        return retval;
<%      when ENUM %>
        return NULL;
<%      else -%>
        return 0;
<%      end -%>
    }
}

bool <%= gname(g) %>_set_<%= f.name %>(object_t group, <%= value_type(f.type) %> value)
{
    bool retval = false;

<%      if @options[:typeAssert] -%>
    BLINK_ASSERT(group->type == TYPE_<%= gname(g) %>)
    
<%      end -%>
        if(group->type == TYPE_<%= gname(g) %>){

        struct <%= gname(g) %> *self = (struct <%= gname(g) %> *)group;
    
<%      case f.type.class
        when STRING, BINARY, FIXED -%>
<%      if f.type.is_a? FIXED or f.type.size -%>
        if(sizeof(self-><%= fname(f) %>.value.data) >= value.size){

            (void)memcpy(self-><%= fname(f) %>.value.data, value.data, value.size);
            retval = true;
        }
        else{
        
            BLINK_ERROR("value is larger than field capacity")
        }
<%      else -%>
        if((self-><%= fname(f) %>.value.data != NULL) && (self->super.a.free != NULL)){

            self->super.a.free(self-><%= fname(f) %>.value.data);
            self-><%= fname(f) %>.value.data = NULL;
            self-><%= fname(f) %>.value.size = 0U;                        
        }
        
        self-><%= fname(f) %>.value.data = self->super.a.calloc(value.size, 1U);

        if(self-><%= fname(f) %>.value.data != NULL){
        
            self-><%= fname(f) %>.value.size = value.size;
            (void)memcpy(self-><%= fname(f) %>.value.data, value.data, value.size);
            retval = true;
        }
        else{

            BLINK_ERROR("calloc()")
        }      
<%      end -%>
<%    when DECIMAL -%>

        self-><%= fname(f) %>.value.mantissa = value.mantissa;
        self-><%= fname(f) %>.value.exponent = value.exponent;
        retval = true;
    
<%    when ENUM -%>
        uint32_t i;
        for(i=0U; i < sizeof(<%= gname(f.type) %>)/sizeof(*<%= gname(f.type) %>); i++){
            if(strncmp(<%= gname(f.type) %>[i].nameLen, <%= gname(f.type) %>[i].name, value) == 0){
                
                self-><%= fname(f) %>.value = <%= gname(f.type) %>[i].value;
                retval = true;
                break;
            }           
        }
<%    when DynamicGroup -%>
        switch(value->type){
<%      f.type.groups.each do |permitted| %>
    case TYPE_<%= cname(permitted.name) %>:
<%      end %>
            self-><%= fname(f) %>.value = value;
            retval = true;
        default:
            BLINK_ERROR("group is incompatible with field")
            break;
        }
<%    when DynamicGroup -%>
        retval = true;
<%    else -%>
        self-><%= fname(f) %>.value = value;
        retval = true;
<%    end -%>
    }

    self-><%=f.name %>.initialised = retval;
    
    return retval;
}

bool <%= gname(g) %>_test_<%= f.name %>(object_t group)
{
    bool retval = false;

<% if @options[:typeAssert] -%>
    BLINK_ASSERT(group->type == TYPE_<%= gname(g) %>)
    
<% end -%>
    if(group->type == TYPE_<%= gname(g) %>){

        struct <%= gname(g) %> *self = (struct <%= gname(g) %> *)group;

        retval = self-><%= fname(f) %>.initialised;
    }
    
    return retval;
}
<%    end # sequence/not-sequence -%>
<%  end # each field -%>
<%end # each group -%>
